<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="keywords" content="blog,java,xtestw">
<meta property="og:type" content="website">
<meta property="og:title" content="XtestW&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="XtestW&#39;s Blog">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="XtestW&#39;s Blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/">





  <title>XtestW's Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">XtestW's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({
      google_ad_client: "ca-pub-1217509255829092",
      enable_page_level_ads: true
    });
  </script>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/01/29/windows-e6-a0-b8-e5-bf-83-e7-bc-96-e7-a8-8b-e9-94-99-e8-af-af-e5-a4-84-e7-90-86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xtestw">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XtestW's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/01/29/windows-e6-a0-b8-e5-bf-83-e7-bc-96-e7-a8-8b-e9-94-99-e8-af-af-e5-a4-84-e7-90-86/" itemprop="url">windows核心编程-错误处理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-01-29T14:04:00+08:00">
                2015-01-29
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ACMICPC/" itemprop="url" rel="index">
                    <span itemprop="name">ACMICPC</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>1.常见的错误返回类型</p>
<p>VOID/BOOL/HANDLE/PVOID/LONG/DWORD VOID 不可能失败 BOOL 错误返回false 编码的时候最好测试是否不为FALSE HANDLE 错误 NULL/INVALID_HANDLE_VALUE PVOID  失败返回NULL,成功返回一个数据块的地址 LONG/DWORD 0或-1，不绝对 2.GetLastError函数   DWORD GetLastError(); 3.WinError.h 头文件定义了若干的Mircosoft定义的代码列表 4.</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/01/29/iocp/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xtestw">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XtestW's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/01/29/iocp/" itemprop="url">IOCP</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-01-29T13:41:00+08:00">
                2015-01-29
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Theory/" itemprop="url" rel="index">
                    <span itemprop="name">Theory</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>IOCP是windows下的一种异步IO通信模式（linux下面对应epoll，二者有区别—&gt;<a href="http://www.cnblogs.com/uzhang/archive/2012/02/24/2365980.html）" target="_blank" rel="noopener">http://www.cnblogs.com/uzhang/archive/2012/02/24/2365980.html）</a></p>
<p>一样的socket的绑定通信的过程，不同的是并不对每一个用户请求单独开设一个线程去处理用户请求，而是在后面一线程池的方式，开固定的线程，轮流处理用户请求，减少线程的上下文切换损耗，同时利用重叠IO，减低内存等资源的消耗。 关于具体的一些内容，见：<a href="http://blog.csdn.net/neicole/article/details/7549497" target="_blank" rel="noopener">http://blog.csdn.net/neicole/article/details/7549497</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2014/12/22/xchart-e6-ba-90-e7-a0-81-e5-88-86-e6-9e-90-ef-bc-881-ef-bc-89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xtestw">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XtestW's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2014/12/22/xchart-e6-ba-90-e7-a0-81-e5-88-86-e6-9e-90-ef-bc-881-ef-bc-89/" itemprop="url">Xchart 源码分析（1）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2014-12-22T07:04:00+08:00">
                2014-12-22
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/SourceReading/" itemprop="url" rel="index">
                    <span itemprop="name">SourceReading</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <pre><code>学校课程需要找一份代码，来讲讲代码里面用了哪些设计模式\- -！ 还是要java的。。。 于是上github上面翻代码，偶然翻到一个java的xchart图标库，感觉可能以后会用的到，而且代码不是很长，就直接拿过来用了。具体的链接地址如下：[https://github.com/timmolter/XChart](https://github.com/timmolter/XChart &quot;https://github.com/timmolter/XChart&quot;)

  先看文件夹结构： [![image](http://images.cnitblog.com/blog/372495/201412/212021296717659.png &quot;image&quot;)](http://images.cnitblog.com/blog/372495/201412/212006353907368.png)           一共有6个包，最后一个是用来测试的包，可以忽略不计，一共5个包，5个包的作用分别是：    com.xeiam.xchart:主要是图表生成的代码以及一些图表的功能包括导出功能的代码，是给我们使用该jar包人调用的结构，表示的是一个图表整体的构造，包括Chart,ChartBuild,Series等类。 [![image](http://images.cnitblog.com/blog/372495/201412/212021319529230.png &quot;image&quot;)](http://images.cnitblog.com/blog/372495/201412/212021311244117.png)     后面4个都是xchart内部实现的类：     com.xeiam.xchart.internal: 这个package里面只有两个类，一个是package-info，我也不是很明白他的作用。。。就是写了一个license的地址。另一个类是Utils的类，提供了两个静态方法，一个求幂的，一个就是求差值的一半。      com.xeiam.xchart.internal.chartpart:这个包里面的东西，都是一些绘图的基本元素，全部是从chartpart中继承过来的，利用组合模式来进行绘制和构造，主要包括Axis,chartTitle,legend,plot等基本图表的元素。 [![image](http://images.cnitblog.com/blog/372495/201412/212021336403214.png &quot;image&quot;)](http://images.cnitblog.com/blog/372495/201412/212021324522145.png)         com.xeiam.xchart.internal.markers：这个包里面，主要是针对刻度的一些绘图，包括圆形，矩形，上下三角形，菱形等。 [![image](http://images.cnitblog.com/blog/372495/201412/212021350622214.png &quot;image&quot;)](http://images.cnitblog.com/blog/372495/201412/212021341246600.png)          com.xeiam.xchart.internal.style: 这个类主要是针对图表的一系列的外观进行定义的包，给出了几个主题，以及对于线的一些类型外观的设置。 [![image](http://images.cnitblog.com/blog/372495/201412/212021364994442.png &quot;image&quot;)](http://images.cnitblog.com/blog/372495/201412/212021356089113.png)            作为一个轻量级的图表库，xchart通过这几个包里面的类进行图像的构造，最终画出一个图形出来，不过目前只能支持有限的几种图表类型。</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2014/09/08/e8-ae-be-e8-ae-a1-e6-a8-a1-e5-bc-8f-e4-bb-a3-e7-90-86-e6-a8-a1-e5-bc-8f/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xtestw">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XtestW's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2014/09/08/e8-ae-be-e8-ae-a1-e6-a8-a1-e5-bc-8f-e4-bb-a3-e7-90-86-e6-a8-a1-e5-bc-8f/" itemprop="url">设计模式-代理模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2014-09-08T09:11:00+08:00">
                2014-09-08
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Design-Pattern/" itemprop="url" rel="index">
                    <span itemprop="name">Design Pattern</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在实际开发的时候，我们同样的一个对象，对于不同的客户，可能能够调用的方法是不一样的，就是权限的控制，这个时候，对象的方法都应该是public，那么就要给对象加上一层，通过客户的类型，决定是否可以访问，也就是说，客户不直接访问对象，而是访问给对象加上的这一层，就是代理层。</p>
<p>public interface T1{<br>    public void method();<br>};<br>public class Item implements T1{<br>    public void method();<br>}<br>public class ItemProxy implements T1{<br>    Item item;<br>    Client client;<br>    public ItemProxy(Client c){<br>        this.Client=c;<br>        this.item=new item();<br>    }<br>    public void method(){<br>        if (client,allow()){<br>            item.method1();<br>        }else{<br>            return;<br>        }<br>    }<br>}<br>public class Client{<br>    T1 t;<br>    public Client()<br>    {<br>        t=new ItemProxy(this);<br>    }<br>    public void method1()<br>    {<br>        t.method();<br>    }<br>}</p>
<p>这样就可以在代理类中，控制对象的访问了，当然代理模式实现方式还有很多种，（远程代理管理客户和远程对象的交互，虚拟代理控制访问实例化开销大的对象，保护代理基于调用者控制对对象方法的访问），上面只是其中的一种方式，代理模式的定义如下：</p>
<p>代理模式：为另一个对象提供一个替身或占位符以访问这个对象。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2014/09/07/e8-ae-be-e8-ae-a1-e6-a8-a1-e5-bc-8f-e7-8a-b6-e6-80-81-e6-a8-a1-e5-bc-8f/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xtestw">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XtestW's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2014/09/07/e8-ae-be-e8-ae-a1-e6-a8-a1-e5-bc-8f-e7-8a-b6-e6-80-81-e6-a8-a1-e5-bc-8f/" itemprop="url">设计模式-状态模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2014-09-07T13:18:00+08:00">
                2014-09-07
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Design-Pattern/" itemprop="url" rel="index">
                    <span itemprop="name">Design Pattern</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>状态模式是针对系统的状态转换的，其主要的定义如下：</p>
<p>状态模式：允许对象在内部状态改变时改变他的行为，对象看起来好像修改了它的类。</p>
<p>为了方便状态转移 我们为状态定义一个通用的接口，然后每一种状态都实现这个接口，而在系统类中，通过构造函数，将系统本身传入状态类中，这样，每一种状态的改变，都可以在自己类的内部完成，同时提高了可扩展性：</p>
<p>public interface State{<br>    public void des();<br>    public void action();<br>}<br>public class State1 implements State{<br>    Sys sys;<br>    public Sate1(Sys s)<br>    {<br>        this.sys=sys;<br>    }<br>    public void des(){<br>        …/ implements<br>    }<br>    public void action(){<br>        …/ change the state<br>        sys.setState(s.getState2());<br>    }<br>}<br>public class State2 implements State{<br>    Sys sys;<br>    public Sate2(Sys s)<br>    {<br>        this.sys=sys;<br>    }<br>    public void des(){<br>        …/ implements<br>    }<br>    public void action(){<br>        …/ change the state<br>        sys.setState(s.getState1());<br>    }<br>}<br>public class Sys {<br>    private State1 state1;<br>    private State2 state2;<br>    private State state;//record the system’s state<br>    ….//state1 &amp; state2’s setter &amp; getter<br>    public Sys(State state)<br>    {<br>        this.state=state;<br>    }<br>    public void setState(State state)<br>    {<br>        this.state=state;<br>    }<br>    public void aciton()<br>    {<br>        state.action();<br>    }<br>}</p>
<p>虽然在实现上 状态模式和策略模式以及模板方法有些相似 但是几个设计模式完全不一样，策略模式是将可以互换的行为封装起来，然后使用委托的方法决定使用哪一个行为，模板方法则是由子类决定具体的如何实现算法中的某些步骤，而算法的流程是给定的，而状态模式则封装的是基于状态的行为，并将行为委托到当前状态，由当前状态来决定具体行为。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2014/09/06/e8-ae-be-e8-ae-a1-e6-a8-a1-e5-bc-8f-e8-bf-ad-e4-bb-a3-e5-99-a8-e6-a8-a1-e5-bc-8f-e5-92-8c-e7-bb-84-e5-90-88-e6-a8-a1-e5-bc-8f/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xtestw">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XtestW's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2014/09/06/e8-ae-be-e8-ae-a1-e6-a8-a1-e5-bc-8f-e8-bf-ad-e4-bb-a3-e5-99-a8-e6-a8-a1-e5-bc-8f-e5-92-8c-e7-bb-84-e5-90-88-e6-a8-a1-e5-bc-8f/" itemprop="url">设计模式-迭代器模式和组合模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2014-09-06T04:52:00+08:00">
                2014-09-06
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Design-Pattern/" itemprop="url" rel="index">
                    <span itemprop="name">Design Pattern</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>1.迭代器模式完成的功能是和迭代器一样的，封装了对对象的顺序遍历，因为子类的对象集合的存储方式可能并不一致。但是存储的对象是一致的。</p>
<p>public classItem{<br>    …..//各种属性<br>}<br>public class Set1{<br>    item[] items;<br>    …<br>    public Iterator createIterator(){<br>        return new ItemIterator(items);<br>    }<br>}<br>public class Set2{<br>    ArrayList items;<br>    …<br>    public Iterator createIterator(){<br>        return  items.iterator();<br>    }<br>}<br>public class ItemIterator implements Iterator{<br>    Item[] items;<br>     int position;<br>    public ItemIterator(Item[] items)<br>    {<br>        this.items=items;<br>        position=0;<br>    }<br>    public Object next()<br>    {<br>        Item i=items[position];<br>        position=position+1;<br>        return i;<br>    }<br>    public boolean hasNext()<br>    {<br>        if (position&gt;=items.lenght || items[position]==null)<br>            return false;<br>        else<br>            return true;<br>    }<br>}</p>
<p>通过这种方法，我们就可以通过自己定义的一个迭代器来访问数组，同时通过createIterator的方法来顺序遍历存储结构不一样的Set1和Set2中item对象。所以迭代器模式就是:</p>
<p>迭代器模式：提供一种方法顺序访问一个聚合对象中的各种元素，而又不暴露其内部的表示。</p>
<p>2.组合模式 组合模式其实就是整体与部分的一个关系，其实就是一个树形结构，根节点由他的子节点组合而成，而子节点又有自己的子节点来组合而成，所以组合模式的定义如下：</p>
<p>组合模式：允许你将对象组合成树形结构来表现“整体/部分”的层次结构，组合能让客户以一致的方法处理个别对象以及对象组合。</p>
<p>现在我们需要对组合模式下的对象这棵进行遍历怎么办？</p>
<p>public abstract class ItemComponent{<br>    ….//方法<br>    public void method1(){<br>    }<br>}<br>public classItem extends ItemComponent{<br>    …..//各种属性<br>    public void method1()<br>    {<br>        System.out.println(“leaf”);<br>    }<br>}<br>public class Set1 extends ItemComponent{<br>    item[] items;<br>    …<br>    public Iterator Iterator(){<br>        return new ItemIterator(items);<br>    }<br>    public void method1()<br>    {<br>        System.out.println(“not leaf”);<br>        Iterator iterator=itemComponent.iterator();//重写<br>        while (iterator.hasNext())<br>        {<br>            ItemComponent t=(ItemComponent) iterator.next();<br>            t.method1();<br>        }<br>    }<br>}<br>public class Set2 extends ItemComponent{<br>    ArrayList items;<br>    …<br>    public Iterator Iterator(){<br>        return  items.iterator();<br>    }<br>        public void method1()<br>    {<br>        System.out.println(“not leaf”);<br>        Iterator iterator=itemComponent.iterator();//重写<br>        while (iterator.hasNext())<br>        {<br>            ItemComponent t=(ItemComponent) iterator.next();<br>            t.method1();<br>        }<br>    }</p>
<p>}</p>
<p>上面这种方式是一种通过递归的方式来实现全部遍历的</p>
<p>public class ItemIterator implements Iterator{<br>    stack stack = new Stack();<br>    public ItemIterator(Iterator iter)<br>    {<br>        stack.push(iter);<br>    }</p>
<pre><code> public Object next()
{
    if (hasNext()){
        Iterator iterator=(Iterator)stack.peek();
        ItemComponent t=(ItemComponent) iterator.next();
        if (t instanceof Set1)
        {
            stack.push(t.createIterator());    
        }
        return t;
    }else{
        return null;
    }
}
public boolean hasNext()
{
    if (stack.empty()){
        return false;
    }else{
        Iterator iterator=(Iterator) stack.peek();
        if (!iterator.hasNext()){
            stack.pop();
            return hasNext();
        }else {
            return true;
        }
    }
}</code></pre><p>}</p>
<p>现在定义的这种方式，是通过迭代器用栈模拟递归的一种方式。 3。设计模式-职责单一</p>
<p>单一责任： 一个类应该只有一个引起变化的原因。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2014/09/05/e8-ae-be-e8-ae-a1-e6-a8-a1-e5-bc-8f-e6-a8-a1-e6-9d-bf-e6-96-b9-e6-b3-95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xtestw">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XtestW's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2014/09/05/e8-ae-be-e8-ae-a1-e6-a8-a1-e5-bc-8f-e6-a8-a1-e6-9d-bf-e6-96-b9-e6-b3-95/" itemprop="url">设计模式-模板方法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2014-09-05T03:36:00+08:00">
                2014-09-05
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Design-Pattern/" itemprop="url" rel="index">
                    <span itemprop="name">Design Pattern</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>前面学习过了策略模式，策略模式是对一类的算法进行封装，利用组合，算法之间可以互相替换，但是这个是针对算法过程不是一样的算法。但是如果一系列的算法的步骤都是一样的，且算法的很多过程都是一样的处理，那么，用策略模式的话，会导致算法的重用不高，我们采用模板方法来实现：</p>
<p>模板方法模式：在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。</p>
<p>public abstract class CAL{<br>    public final void algorithm()<br>    {<br>        A1();<br>        A2();<br>        if (Judge())<br>            A3();<br>        A4();<br>    }<br>    public void A1(){<br>        //实现<br>        …..<br>    }<br>    public  void A2(){<br>        //实现<br>        …..<br>    }<br>    public abstract void A3(){}<br>    public abstract void A4(){}<br>    public boolean Judge(){<br>        return true;<br>    }<br>}</p>
<p>其中模板类是一个抽象类，其中算法是确定了的，A1，A2是公共的方法，所有的子类都是一样的，A3，A4是子类自己实现的不一样的函数，定义为抽象方法，子类实现，而Judge方法被成为钩子，默认返回true，而子类可以重写这个方法，这样就能让子类拥有自己的方法。但是这个也反应了模板方法的一个缺点，就是与策略模式相比，弹性不足。   设计模式-好莱坞模式</p>
<p>好莱坞模式：别调用我们，我们会调用你。</p>
<p>允许低层组件将自己挂钩到系统上，但是高层组件会决定什么时候和怎样使用这些低层组件。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2014/09/04/e8-ae-be-e8-ae-a1-e6-a8-a1-e5-bc-8f-e9-80-82-e9-85-8d-e5-99-a8-e6-a8-a1-e5-bc-8f-e5-92-8c-e5-a4-96-e8-a7-82-e6-a8-a1-e5-bc-8f/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xtestw">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XtestW's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2014/09/04/e8-ae-be-e8-ae-a1-e6-a8-a1-e5-bc-8f-e9-80-82-e9-85-8d-e5-99-a8-e6-a8-a1-e5-bc-8f-e5-92-8c-e5-a4-96-e8-a7-82-e6-a8-a1-e5-bc-8f/" itemprop="url">设计模式-适配器模式和外观模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2014-09-04T05:46:00+08:00">
                2014-09-04
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Design-Pattern/" itemprop="url" rel="index">
                    <span itemprop="name">Design Pattern</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>1.适配器模式 适配器模式是针对接口不一时处理的情况，比如我的类的参数是IInterface1，但是我现在想要调用IInterface2接口的函数，怎么办呢？就是用适配器来解决这个问题：</p>
<p>public interface IInterface1(){<br>    public void method1();<br>}<br>public interface IInterface2(){<br>    public void method2();<br>}<br>public class adapter implements IInterface1{<br>    IInterface2 v;<br>    public adapter(IInterface2 t){<br>        this.v=t;<br>    }<br>    public void method1(){<br>        v.method2();<br>    }<br>}</p>
<p>现在我们调用IIterface2的method1的方法的时候，就是可以直接构造一个适配器来完成</p>
<p>public class A{</p>
<pre><code>public void method3(IInterface1 t)
{
    t.method1();
}

public static void main(String\[\] arg)
{
    (new A()).method3(new adapter(claimplementInterfce2));
}</code></pre><p>}</p>
<p>其中claimplementInterface2是实现Interface2的一个类的实例。这种适配器的方法被称作为对象适配器，还有一种适配器，叫做类适配器，是基于类的多继承的，其中适配器继承自要适配的两个类，用其中一个类的方法调用另一个类，思想是一致的，不过java不支持多继承，所以也就是只能用对象适配器。</p>
<p>适配器模式：将一个类的接口，转换成客户期望的另一个接口，适配器让原本接口不兼容的类可以合作无间</p>
<p>2.外观模式 外观模式，其实就是对一个子系统的方法进行整理，对外公开一些方法，方便外部的调用，但是并不是对这些类的一个封装，只是提供了一个简单的接口，用户如果觉得没什么用出，可以直接调用子系统的方法，而且，一个子系统可以有很多个外观。所以外观模式的定义如下</p>
<p>外观模式：提供一个统一的接口，用来访问子系统的一群接口。外观定义了一个高层接口，让子系统更容易使用。</p>
<p>比如我们用电脑，怎么开机，怎么关机呢：  </p>
<p>public class UseComputer{<br>    ZHUJI zhuji;<br>                XIANSHIQI xianshiqi;<br>            …<br>    public UseComputer(ZHUJI zhuji,XIANSHIQI xianshiqi,….)<br>    {<br>        this.zhuji=zhuji;<br>        this.xianshiqi=xianshiqi;<br>        …..<br>    }<br>    public void guanji()<br>    {<br>        zhuji.off();<br>        xianshiqi.off();<br>    }<br>    public void kaiji()<br>    {<br>        xianshiqi.on();<br>        zhuji.on();<br>    }<br>}</p>
<p>这样就直接提供给用户开机和关机的操作了，而不用用户自己去调用开机关机的一系列的方法了。 3.设计原则</p>
<p>最少知识原则：只和你的密友谈话</p>
<p>需要做到这个原则，建议只调用一下的范围的方法：</p>
<p>对象本身<br>被当作方法的参数而传递进来的对象<br>此方法所创建或实例化的任何对象<br>对象的任何组组件</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2014/09/03/e8-ae-be-e8-ae-a1-e6-a8-a1-e5-bc-8f-e5-91-bd-e4-bb-a4-e6-a8-a1-e5-bc-8f/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xtestw">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XtestW's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2014/09/03/e8-ae-be-e8-ae-a1-e6-a8-a1-e5-bc-8f-e5-91-bd-e4-bb-a4-e6-a8-a1-e5-bc-8f/" itemprop="url">设计模式-命令模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2014-09-03T05:26:00+08:00">
                2014-09-03
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Design-Pattern/" itemprop="url" rel="index">
                    <span itemprop="name">Design Pattern</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>命令模式这个设计模式更像是对接口编程的一种应用，比如给小朋友穿衣服，但是不一样的衣服有不一样的穿法，裤子，衬衫，鞋，T恤都是不一样的，但是小朋友不知道怎么穿，只知道想穿什么，那么怎么办呢，小朋友会让他的妈妈帮他穿，这里面的“让妈妈帮忙”，就是给妈妈一个命令（虽然不是很恰当- -！），对小朋友而言，怎么穿他并不关心，反正只要有只要让妈妈穿就行了，所以我们只要定义一个穿的接口就行</p>
<p>public interface Wear()<br>{<br>    public void excute();<br>}</p>
<p>然后继承这个穿，有很多种执行方式，比如穿鞋，穿衬衫，穿裤子</p>
<p>public class WearShoe implements Wear{<br>    public void excute()<br>    {<br>        …..//穿鞋的动作<br>    }<br>}<br>public class WearShirt implements Wear{<br>    public void excute()<br>    {<br>        …..//穿衬衫的动作<br>    }<br>}<br>public class WearPants implements Wear{<br>    public void excute()<br>    {<br>        …..//穿裤子的动作<br>    }<br>}</p>
<p>对于妈妈来说，只要知道小朋友要穿什么，帮他穿上就好了：</p>
<p>public class Mom{<br>    Wear wear;<br>    public setCommand(Wear wear)<br>    {<br>        this.wear = wear;<br>    }<br>    public void Do()<br>    {<br>        wear.excute();<br>    }<br>}</p>
<p>小朋友要做的事就是告诉妈妈我想穿什么，让妈妈帮它穿好就行了，具体怎么穿，他才不管呢  </p>
<p>public class Child{<br>    public static void main()<br>    {<br>        Mom mom=new Mom();<br>        WearShoe wearShoe=new WearShoe();<br>        WearPants wearPants=new WearPants();<br>        mom.setCommand(wearShoe);<br>        mom.excute();<br>        mom.setCommand(wearPants);<br>        mom.excute();<br>    }<br>}</p>
<p>所以可以看出命令模式其实就是：</p>
<blockquote>
<p>命令模式：将“请求”封装成对象，以便使用不同的请求、队列或者日志来参数化其他对象，命令模式也支持可撤销的操作</p>
</blockquote>
<p>其中可撤销的操作其实就是在接口中加入脱衣服的接口，这样子既可以帮小朋友穿衣服也可以帮他脱掉衣服：</p>
<p>public interface Wear()<br>{<br>    public void excute();<br>    public void undo();<br>}</p>
<p>然后再实现接口的对象中实现它就可以了。   命令模式在多线程处理任务的时候非常有效，只要将命令封装的对象，放入任务队列中，不同的线程通过队列获取对象，直接执行对象的excute()方法就行，而不用管具体命令是怎么执行的。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2014/09/02/e8-ae-be-e8-ae-a1-e6-a8-a1-e5-bc-8f-e5-8d-95-e4-bb-b6-e6-a8-a1-e5-bc-8f/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xtestw">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XtestW's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2014/09/02/e8-ae-be-e8-ae-a1-e6-a8-a1-e5-bc-8f-e5-8d-95-e4-bb-b6-e6-a8-a1-e5-bc-8f/" itemprop="url">设计模式-单件模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2014-09-02T06:42:00+08:00">
                2014-09-02
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Design-Pattern/" itemprop="url" rel="index">
                    <span itemprop="name">Design Pattern</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>工程中，某些对象我们只需要一个，比如线程池，缓存，对话框等的对象，我们通常的做法是可以定一个全局静态变量，然后通过程序初始化的时候就实例化他们，然后直接调用这个全局变量，但是这样有个问题，如果我的这个对象消耗的资源很多，而有的时候，我的程序在运行过程中又没用到这个对象，岂不是浪费了很多资源。通常的做法就是定义全局静态变量的时候，不初始化他，而是在调用过程中实例化，这样的话，对于全局变量的实例化，我们就要判断这个变量是否已经实例化了，如果实例化了的吧，我们就不对它进行实例化，所以代码如下：</p>
<p>public class A<br>{<br>    private A(){}<br>    public static A cla;<br>    public static A getInstance()<br>    {<br>        if (cla == null){<br>            cla=new A();<br>        }<br>        return cla;<br>    }<br>}</p>
<p>这里的A的构造器是私有的，这样子可以有效的保证A这个类不会再外部被实例化，从而保证他的唯一性，我们通过getInstance来获取A的全局唯一变量cla，这样就有效的解决了上面这个问题，但是问题又来了，多线程访问getInstance()的时候？cla完全可能出现实例化一次之后又被实例化，怎么办？</p>
<p>public class A<br>{<br>    private A(){}<br>    public static A cla;<br>    public static synchronized A getInstance()<br>    {<br>        if (cla == null){<br>            cla=new A();<br>        }<br>        return cla;<br>    }<br>}</p>
<p>我们就为A获取实力的方法getInstance增加一个同步锁来保证方法只能被唯一访问，可是，同步锁势必会降低运行效率，而且我们发现，事实上，也就是第一次实例化的时候会出现问题需要同步锁，以后再需要获取这个对象的时候完全不需要，如果我们频繁的获取对象的话，效率的影响就会相当大。回到最开始的做法?设置全局变量，程序运行的时候就实例化对象？</p>
<p>public class A<br>{<br>    private A(){}<br>    public static A cla = new A();<br>    public static synchronized A getInstance()<br>    {<br>        return cla;<br>     }<br>}</p>
<p>这个确实是种方法，但始终不是最好的方法，我们想到，之前所说的，只有在实例化的时候才需要同步锁，那么我们就想到采用双重检查加锁的方法，只在实例化的时候加锁：</p>
<p>public class A<br>{<br>    private A(){}<br>    public volatile static A cla;<br>    public static A getInstance()<br>    {<br>         if (cla == null){<br>            synchronized(A.class){<br>                if (cla==null){<br>                    cla=new A();<br>                }<br>            }<br>          }<br>        return cla;<br>    }<br>}</p>
<p>其中volatile的关键字是确保多线程在cla变量初始化的时候，正确的处理cla变量。(volatile用在多线程，同步变量。 线程为了提高效率，将某成员变量(如A)拷贝了一份（如B），线程中对A的访问其实访问的是B。只在某些动作时才进行A和B的同步。因此存在A和B不一致的情况。volatile就是用来避免这种情况的。volatile告诉jvm， 它所修饰的变量不保留拷贝，直接访问主内存中的（也就是上面说的A))</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">xtestw</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">40</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">categories</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">xtestw</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
